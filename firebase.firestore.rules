// ============================================
// FIRESTORE SECURITY RULES
// ============================================
// Copy these to Firebase Console -> Firestore -> Rules

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Users can read their own profile
      allow read: if request.auth != null && request.auth.uid == userId;

      // Users can write their own profile (except roles - that's managed by signup)
      allow write: if request.auth != null
        && request.auth.uid == userId;

      // Authenticated users can list and read other users' public profile data
      // This allows promoters to browse influencers
      // Only public fields should be accessible (no private data)
      allow read: if request.auth != null;
    }

    // ============================================
    // PROMOTERS SUBCOLLECTION (for saved influencers, etc.)
    // ============================================
    match /promoters/{promoterId} {
      // Only the promoter can access their own data
      allow read, write: if request.auth != null && request.auth.uid == promoterId;

      // Saved influencers subcollection
      match /saved/influencers {
        allow read, write: if request.auth != null && request.auth.uid == promoterId;
      }
    }

    // ============================================
    // PROPOSALS COLLECTION
    // ============================================
    match /proposals/{proposalId} {
      // Allow authenticated users to query proposals collection
      // Individual documents are filtered by influencerId/promoterId in the query
      // Note: Firestore rules don't check query conditions, so we allow list for auth users
      // The actual filtering happens in the query (where influencerId/promoterId == uid)
      allow list: if request.auth != null;

      // Only involved parties can read individual proposal documents
      allow get: if request.auth != null
        && (resource.data.influencerId == request.auth.uid
          || resource.data.promoterId == request.auth.uid);

      // Combined read permission for convenience
      allow read: if request.auth != null;

      // Promoters can create proposals
      allow create: if request.auth != null
        && request.resource.data.promoterId == request.auth.uid;

      // Only involved parties can update
      allow update: if request.auth != null
        && (resource.data.influencerId == request.auth.uid
          || resource.data.promoterId == request.auth.uid);

      // Allow status updates with validation
      allow update: if request.auth != null
        && (resource.data.influencerId == request.auth.uid
          || resource.data.promoterId == request.auth.uid)
        && request.resource.data.status in ['pending', 'discussing', 'finalized', 'in_progress', 'completed', 'cancelled'];

      // Influencer can update their approval/submission
      allow update: if request.auth != null
        && resource.data.influencerId == request.auth.uid
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['influencerApproval']);

      // Promoter can update their approval and payment status
      allow update: if request.auth != null
        && resource.data.promoterId == request.auth.uid
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['brandApproval', 'advancePaid', 'finalAmount', 'advanceAmount', 'remainingAmount', 'completionPercentage']);

      // Delete only if not in progress
      allow delete: if request.auth != null
        && (resource.data.promoterId == request.auth.uid)
        && resource.data.status in ['pending', 'discussing'];
    }

    // ============================================
    // CONVERSATIONS COLLECTION
    // ============================================
    match /conversations/{conversationId} {
      // Allow authenticated users to query conversations they participate in
      allow list: if request.auth != null;

      // Only participants can read individual conversations
      allow get: if request.auth != null
        && request.auth.uid in resource.data.participants;

      // Combined read permission
      allow read: if request.auth != null;

      // Users can create direct conversations
      // Proposal conversations are auto-created when proposal is created
      allow create: if request.auth != null
        && request.resource.data.type == 'direct'
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.participants.keys().size() == 2; // Direct chat = 2 participants

      // Only participants can update (e.g., mark as read, leave conversation)
      allow update: if request.auth != null
        && request.auth.uid in resource.data.participants;

      // Participants can leave conversations
      allow delete: if request.auth != null
        && request.auth.uid in resource.data.participants
        && resource.data.participants.keys().hasOnly([request.auth.uid]);
    }

    // ============================================
    // MESSAGES COLLECTION
    // ============================================
    match /messages/{messageId} {
      // Allow authenticated users to query messages
      allow list: if request.auth != null;

      // Only sender or receiver can read messages
      allow get: if request.auth != null
        && (resource.data.senderId == request.auth.uid
          || resource.data.receiverId == request.auth.uid);

      // Combined read permission
      allow read: if request.auth != null;

      // Senders can create messages (must have conversationId)
      allow create: if request.auth != null
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.conversationId != null;

      // Sender can update/delete their messages
      allow update, delete: if request.auth != null
        && resource.data.senderId == request.auth.uid;

      // Receiver can update read status
      allow update: if request.auth != null
        && resource.data.receiverId == request.auth.uid
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
    }

    // ============================================
    // REVIEWS COLLECTION
    // ============================================
    match /reviews/{reviewId} {
      // Anyone can read reviews
      allow read: if true;

      // Only reviewer can create their own review
      allow create: if request.auth != null
        && request.resource.data.reviewerId == request.auth.uid;

      // Only reviewer can update their own review (within 24 hours)
      allow update: if request.auth != null
        && resource.data.reviewerId == request.auth.uid
        && (request.time - resource.data.createdAt) < 86400000; // 24 hours

      // No deletion of reviews
    }

    // ============================================
    // TRANSACTIONS COLLECTION
    // ============================================
    match /transactions/{transactionId} {
      // Only payer and receiver can read
      allow read: if request.auth != null
        && (resource.data.payerId == request.auth.uid
          || resource.data.receiverId == request.auth.uid);

      // Only Firebase Functions can write (payment processing)
      allow write: if false;
    }

    // ============================================
    // INDEXES QUERY HELPERS
    // ============================================
    // These are hints for composite indexes
    // Create these in Firebase Console -> Firestore -> Indexes

    // influencerId_status index for influencer proposals
    // promoterId_status index for promoter proposals
    // proposalId_timestamp index for messages
    // revieweeId_rating index for reviews
  }
}
